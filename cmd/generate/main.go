package main

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"sort"
	"strings"
	"text/template"

	"gopkg.in/yaml.v3"
)

type PacketDef struct {
	Name        string `yaml:"name"`
	Value       string `yaml:"value"`
	Category    string `yaml:"category"`
	Description string `yaml:"description"`
}

type PacketSpec struct {
	Packets []PacketDef `yaml:"packets"`
}

type FlagDef struct {
	Name        string `yaml:"name"`
	Bit         int    `yaml:"bit"`
	Description string `yaml:"description"`
}

type FlagSpec struct {
	Flags []FlagDef `yaml:"flags"`
}

const genTemplate = `// Code generated by cmd/generate/main.go. DO NOT EDIT.

package protocol

const (
{{range $category, $packets := .Categories}}
	// {{$category}}
{{range $packets}}	PacketType{{.Name}} PacketType = {{.Value}}{{if .Description}} // {{.Description}}{{end}}
{{end}}
{{end}})

var (
	PacketTypeMap = []PacketTypeMapping{
{{range .Packets}}		{PacketType: PacketType{{.Name}}, String: "{{.Name}}"},
{{end}}	}

	PacketTypeMapType = func() map[PacketType]string {
		m := make(map[PacketType]string)
		for _, mapping := range PacketTypeMap {
			m[mapping.PacketType] = mapping.String
		}
		return m
	}()
)
`

const flagsGenTemplate = `// Code generated by cmd/generate/main.go. DO NOT EDIT.

package protocol

import "strings"

const (
{{range .Flags}}	Flag{{.Name}} Flag = 1 << {{.Bit}}{{if .Description}} // {{.Description}}{{end}}
{{end -}}
)

var flagNames = []struct {
	flag Flag
	name string
}{
{{range .Flags}}	{Flag{{.Name}}, "{{.Name}}"},
{{end}}
}

func (f Flag) String() string {
	if f == 0 {
		return "0"
	}
	var parts []string
	for _, n := range flagNames {
		if f&n.flag != 0 {
			parts = append(parts, n.name)
		}
	}
	return strings.Join(parts, "|")
}
`

func main() {
	// Find protocol directory (where this script is located)
	scriptDir := filepath.Dir(os.Args[0])
	if strings.Contains(scriptDir, "/tmp/") || strings.Contains(scriptDir, "go-build") {
		// If run via go run, get the actual source directory
		wd, err := os.Getwd()
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error getting working directory: %v\n", err)
			os.Exit(1)
		}
		scriptDir = wd
	}

	protocolDir := filepath.Join(scriptDir, "..", "..")
	if !strings.HasSuffix(protocolDir, "protocol") {
		// Try to find protocol directory from current working directory
		wd, err := os.Getwd()
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error getting working directory: %v\n", err)
			os.Exit(1)
		}
		// Walk up to find protocol directory
		dir := wd
		for {
			if filepath.Base(dir) == "protocol" {
				protocolDir = dir
				break
			}
			parent := filepath.Dir(dir)
			if parent == dir {
				fmt.Fprintf(os.Stderr, "Could not find protocol directory\n")
				os.Exit(1)
			}
			dir = parent
		}
	}

	yamlPath := filepath.Join(protocolDir, "packets.yaml")
	outputPath := filepath.Join(protocolDir, "types_gen.go")

	// Read YAML file
	data, err := os.ReadFile(yamlPath)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error reading %s: %v\n", yamlPath, err)
		os.Exit(1)
	}

	var spec PacketSpec
	if err := yaml.Unmarshal(data, &spec); err != nil {
		fmt.Fprintf(os.Stderr, "Error parsing YAML: %v\n", err)
		os.Exit(1)
	}

	// Group packets by category
	categories := make(map[string][]PacketDef)
	for _, packet := range spec.Packets {
		categories[packet.Category] = append(categories[packet.Category], packet)
	}

	// Sort categories and packets within categories
	categoryOrder := make([]string, 0, len(categories))
	for cat := range categories {
		categoryOrder = append(categoryOrder, cat)
	}
	sort.Strings(categoryOrder)

	sortedCategories := make(map[string][]PacketDef)
	for _, cat := range categoryOrder {
		packets := categories[cat]
		// Sort packets by value
		sort.Slice(packets, func(i, j int) bool {
			return packets[i].Value < packets[j].Value
		})
		sortedCategories[cat] = packets
	}

	// Prepare template data
	tmplData := struct {
		Categories map[string][]PacketDef
		Packets    []PacketDef
	}{
		Categories: sortedCategories,
		Packets:    spec.Packets,
	}

	// Generate code
	tmpl, err := template.New("types").Parse(genTemplate)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error parsing template: %v\n", err)
		os.Exit(1)
	}

	var buf strings.Builder
	if err := tmpl.Execute(&buf, tmplData); err != nil {
		fmt.Fprintf(os.Stderr, "Error executing template: %v\n", err)
		os.Exit(1)
	}

	// Write output file
	if err := os.WriteFile(outputPath, []byte(buf.String()), 0644); err != nil {
		fmt.Fprintf(os.Stderr, "Error writing %s: %v\n", outputPath, err)
		os.Exit(1)
	}

	// Format the generated file with gofmt
	cmd := exec.Command("gofmt", "-w", outputPath)
	if err := cmd.Run(); err != nil {
		fmt.Fprintf(os.Stderr, "Warning: gofmt failed on %s: %v\n", outputPath, err)
		// Don't exit - the file was generated, just not formatted
	}

	fmt.Printf("Generated %s from %s\n", outputPath, yamlPath)

	// Generate flags_gen.go from flags.yaml
	flagsYAMLPath := filepath.Join(protocolDir, "flags.yaml")
	flagsOutputPath := filepath.Join(protocolDir, "flags_gen.go")
	flagsData, err := os.ReadFile(flagsYAMLPath)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error reading %s: %v\n", flagsYAMLPath, err)
		os.Exit(1)
	}
	var flagSpec FlagSpec
	if err := yaml.Unmarshal(flagsData, &flagSpec); err != nil {
		fmt.Fprintf(os.Stderr, "Error parsing flags YAML: %v\n", err)
		os.Exit(1)
	}
	flagsTmpl, err := template.New("flags").Parse(flagsGenTemplate)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error parsing flags template: %v\n", err)
		os.Exit(1)
	}
	var flagsBuf strings.Builder
	if err := flagsTmpl.Execute(&flagsBuf, flagSpec); err != nil {
		fmt.Fprintf(os.Stderr, "Error executing flags template: %v\n", err)
		os.Exit(1)
	}
	if err := os.WriteFile(flagsOutputPath, []byte(flagsBuf.String()), 0644); err != nil {
		fmt.Fprintf(os.Stderr, "Error writing %s: %v\n", flagsOutputPath, err)
		os.Exit(1)
	}
	cmd = exec.Command("gofmt", "-w", flagsOutputPath)
	if err := cmd.Run(); err != nil {
		fmt.Fprintf(os.Stderr, "Warning: gofmt failed on %s: %v\n", flagsOutputPath, err)
	}
	fmt.Printf("Generated %s from %s\n", flagsOutputPath, flagsYAMLPath)
}
